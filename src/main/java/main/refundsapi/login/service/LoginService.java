package main.refundsapi.login.service;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import io.jsonwebtoken.io.Decoders;import io.jsonwebtoken.security.Keys;import lombok.RequiredArgsConstructor;import main.refundsapi.login.domain.dto.LoginDto;import main.refundsapi.user.domain.dto.TokenDto;import main.refundsapi.user.enums.UserCode;import main.refundsapi.user.exception.UserException;import main.refundsapi.user.repository.UserRepository;import org.springframework.beans.factory.annotation.Value;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import java.security.Key;import java.util.Date;@Service@RequiredArgsConstructorpublic class LoginService {    @Value("${jwt.secret}") private String secret;    @Value("${jwt.token-validity-in-seconds}") private long tokenValidityInMilliseconds;    private final UserRepository userRepository;    private final PasswordEncoder bCryptPasswordEncoder;    public TokenDto login(LoginDto loginDto){        var findUser = userRepository.findByUserId(loginDto.getUserId()).orElseThrow(() -> new UserException(UserCode.USER_NOT_FOUND));        if(bCryptPasswordEncoder.matches(loginDto.getPassword(), findUser.getPassword())){            long now = (new Date()).getTime();            Date validity = new Date(now + this.tokenValidityInMilliseconds);            return new TokenDto(Jwts.builder()                    .setSubject(findUser.getUserId())                    .claim("userId", findUser.getUserId())                    .claim("name", findUser.getName())                    .signWith(secretKeyDecode(), SignatureAlgorithm.HS512)                    .setExpiration(validity)                    .compact());        }else{            throw new UserException(UserCode.USER_LOGIN_FAIL);        }    }    public Key secretKeyDecode() {        byte[] keyBytes = Decoders.BASE64.decode(secret);        return Keys.hmacShaKeyFor(keyBytes);    }}